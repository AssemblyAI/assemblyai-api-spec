---
title: "Speech-to-Speech"
description: "Speech-to-speech API docs"
---

```
https://aaigentsv1.up.railway.app
```

<Note>This is an early stage product subject to change and should not be used for production usage.</Note>

## Authentication

All REST endpoints require an `Authorization` header:

```
Authorization: YOUR_API_KEY
```

---

## REST API

### Create or Update Agent

`POST /agents`

Create or update an agent configuration.

**Request Body**

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `agent_name` | string | Yes | - | Unique identifier (letters, numbers, underscores only) |
| `instructions` | string | No | null | System prompt for the agent |
| `voice` | string | No | `"luna"` | TTS voice name |
| `llm` | string | No | null | LLM model name (e.g., `"openai/gpt-oss-120b"`) |
| `greeting` | string | No | null | Initial greeting instructions |
| `temperature` | float | No | `0.8` | LLM temperature |
| `max_tokens` | int | No | `4096` | Max tokens for LLM response |
| `language` | string | No | `"en"` | Language code |
| `tools` | array | No | null | Tool definitions |
| `audio_in_sample_rate` | int | No | `16000` | Input audio sample rate |
| `audio_out_sample_rate` | int | No | `16000` | Output audio sample rate |

**Response**

```json
{
  "success": true,
  "agent_name": "my_agent",
  "message": "Agent 'my_agent' configuration saved"
}
```

---

### List Agents

`GET /agents`

List all agents for the authenticated user.

**Response**

```json
{
  "agents": ["agent1", "agent2"],
  "count": 2
}
```

---

### Get Agent Configuration

`GET /agents/{agent_name}`

Get configuration for a specific agent.

**Response**

```json
{
  "agent_name": "my_agent",
  "config": {
    "instructions": "...",
    "voice": "luna",
    "llm": "openai/gpt-oss-120b"
  }
}
```

---

### List Agent Conversations

`GET /agents/{agent_name}/conversations`

List all conversations for an agent.

**Response**

```json
{
  "agent_name": "my_agent",
  "conversations": [
    {
      "conversation_id": "uuid",
      "room_name": "...",
      "timestamp": "2025-12-18T13:00:00Z",
      "created_at": "2025-12-18T13:00:00Z"
    }
  ],
  "count": 1
}
```

---

### Get Conversation

`GET /agents/{agent_name}/conversations/{conversation_id}`

Get a specific conversation.

**Response**

```json
{
  "conversation_id": "uuid",
  "agent_name": "my_agent",
  "room_name": "...",
  "timestamp": "2025-12-18T13:00:00Z",
  "items": [],
  "created_at": "2025-12-18T13:00:00Z"
}
```

---

## WebSocket API

### Connect to Agent

```
wss://aaigentsv1.up.railway.app/ws/{agent_name}
```

Connect to establish a real-time voice chat session with a specific agent. **No authentication required** (agent must exist).

---

## Server Events

### session.created

Sent when the WebSocket connection is established.

**Response**

```json
{
  "type": "session.created",
  "session": {
    "id": "uuid",
    "agent_name": "my_agent"
  }
}
```

### conversation.item.done

Final transcript when a conversation turn completes.

**Response**

```json
{
  "type": "conversation.item.done",
  "item": {
    "id": "uuid",
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "What's the weather like?"
      }
    ]
  }
}
```

**Properties**

| Property | Type | Description |
|----------|------|-------------|
| `type` | string | Event type: `"conversation.item.done"` |
| `item` | object | Conversation item |
| `item.id` | string | Item identifier |
| `item.role` | string | `"user"` or `"assistant"` |
| `item.content` | array | Content parts |
| `item.content[].type` | string | `"text"` |
| `item.content[].text` | string | Transcript text |

### conversation.item.interim

Interim transcript during speech recognition.

**Response**

```json
{
  "type": "conversation.item.interim",
  "item": {
    "id": "uuid",
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "What's the wea..."
      }
    ]
  }
}
```

### tool.call

Function call request from AI agent.

**Response**

```json
{
  "type": "tool.call",
  "call_id": "call_abc123",
  "name": "get_weather",
  "arguments": {
    "location": "San Francisco"
  }
}
```

**Properties**

| Property | Type | Description |
|----------|------|-------------|
| `type` | string | Event type: `"tool.call"` |
| `call_id` | string | Unique call identifier |
| `name` | string | Tool name |
| `arguments` | object | Tool arguments |

### Audio Stream (Server)

Raw PCM audio response as binary WebSocket frames.

**Format**
- Encoding: PCM16 (16-bit signed integer, little-endian)
- Sample Rate: Matches agent's `audio_out_sample_rate` configuration
- Channels: 1 (mono)

---

## Client Events

### Audio Stream (Client)

Send raw PCM audio as binary WebSocket frames.

**Format**
- Encoding: PCM16 (16-bit signed integer, little-endian)
- Sample Rate: Must match agent's `audio_in_sample_rate` configuration (default: 16000 Hz)
- Channels: 1 (mono)

---

## Tools / Function Calling

Define tools in the agent's `tools` configuration via `POST /agents`:

**Tool Definition Schema**

```json
{
  "name": "string",           // Required - unique tool identifier
  "description": "string",    // Required - what the tool does (shown to LLM)
  "parameters": {             // Required - JSON Schema for parameters
    "type": "object",
    "properties": {
      "param_name": {
        "type": "string",     // "string" | "number" | "boolean" | "array" | "object"
        "description": "string"
      }
    },
    "required": ["param_name"]
  }
}
```

**Properties**

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `name` | string | Yes | Unique tool identifier |
| `description` | string | Yes | What the tool does (shown to LLM) |
| `parameters` | object | Yes | JSON Schema for parameters |
| `parameters.type` | string | Yes | Must be `"object"` |
| `parameters.properties` | object | Yes | Object defining each parameter |
| `parameters.properties.<param>.type` | string | Yes | JSON type: `"string"`, `"number"`, `"boolean"`, `"array"`, `"object"` |
| `parameters.properties.<param>.description` | string | No | Parameter description for LLM |
| `parameters.required` | array | No | List of required parameter names |

**Example Tool**

```json
{
  "name": "search_docs",
  "description": "Search the documentation to answer user questions about the API",
  "parameters": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "The search query"
      },
      "limit": {
        "type": "number",
        "description": "Maximum number of results to return"
      }
    },
    "required": ["query"]
  }
}
```

**Full POST Example with Tools**

```json
{
  "agent_name": "my_agent",
  "instructions": "You are a helpful assistant.",
  "tools": [
    {
      "name": "search_docs",
      "description": "Search documentation",
      "parameters": {
        "type": "object",
        "properties": {
          "query": {"type": "string", "description": "Search query"}
        },
        "required": ["query"]
      }
    },
    {
      "name": "get_weather",
      "description": "Get current weather for a location",
      "parameters": {
        "type": "object",
        "properties": {
          "city": {"type": "string", "description": "City name"},
          "units": {"type": "string", "description": "celsius or fahrenheit"}
        },
        "required": ["city"]
      }
    }
  ]
}
```

**Handling Tool Calls**

When the agent calls a tool, the server sends a `tool.call` event. Your client executes the function and sends the result back via `tool.result`.

**Tool Result Schema**

```json
{
  "type": "tool.result",
  "call_id": "string",    // Required - matches the call_id from tool.call
  "result": "string"      // Required - the tool's response (usually JSON stringified)
}
```

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `type` | string | Yes | Must be `"tool.result"` |
| `call_id` | string | Yes | Must match the `call_id` from the `tool.call` event |
| `result` | string | Yes | JSON-encoded function result |

**Example Flow**

1. **Agent sends `tool.call`** (server to client):

```json
{
  "type": "tool.call",
  "call_id": "call_abc123",
  "name": "search_docs",
  "arguments": {
    "query": "how to transcribe audio"
  }
}
```

2. **Client executes tool and sends `tool.result`** (client to server):

```json
{
  "type": "tool.result",
  "call_id": "call_abc123",
  "result": "{\"results\": [{\"title\": \"Getting Started\", \"content\": \"...\"}]}"
}
```

The agent continues its response using the tool result.

---

## Supported Languages

Values for agent `language` configuration:

| Code | Language |
|------|----------|
| `en` | English (default) |

---

## Available LLMs

Values for agent `llm` configuration:

| Slug | Model |
|------|-------|
| `openai/gpt-oss-120b` | OpenAI GPT OSS 120B |
| `deepseek-ai/DeepSeek-V3.2` | Deepseek V3.2 |
| `deepseek-ai/DeepSeek-V3.1` | Deepseek V3.1 |
| `deepseek-ai/DeepSeek-V3-0324` | Deepseek V3 0324 |
| `moonshotai/Kimi-K2-Thinking` | Kimi K2 Thinking |
| `moonshotai/Kimi-K2-Instruct-0905` | Kimi K2 0905 |
| `Qwen/Qwen3-Coder-480B-A35B-Instruct` | Qwen3 Coder 480B |
| `zai-org/GLM-4.6` | Z AI GLM4.6 |

---

## Available Voices

Values for agent `voice` configuration:

| Voice ID | Description |
|----------|-------------|
| `luna` | Female, chill but excitable, gen-z optimist |
| `celeste` | Female, warm, laid-back, fun-loving |
| `orion` | Male, older, African American, happy |
| `ursa` | Male, 20 years old, encyclopedic knowledge of 2000s emo |
| `astra` | Female, young, wide-eyed |
| `esther` | Female, older, Chinese American, loving |
| `estelle` | Female, middle-aged, African American, sounds so sweet |
| `andromeda` | Female, young, breathy, yoga vibes |

---

## Example

### Python

**Installation**

```bash
pip install websockets sounddevice numpy
```

**Code**

```python
import asyncio
import json
import websockets
import sounddevice as sd
import numpy as np
import contextlib

URI = "wss://aaigentsv1.up.railway.app/ws/{agent_name}"

async def voice_chat():
    queue = asyncio.Queue(maxsize=100)
    session_ready = False
    interim_active = False

    async with websockets.connect(URI, ping_interval=10, ping_timeout=20) as websocket:
        print(f"Connected to {URI}")

        async def sender():
            audio_count = 0
            while True:
                try:
                    data = await queue.get()
                    if session_ready:
                        await websocket.send(data)
                        audio_count += 1
                finally:
                    queue.task_done()

        sender_task = asyncio.create_task(sender())
        loop = asyncio.get_running_loop()
        
        def mic_callback(indata, frames, time, status):
            if status.input_overflow:
                print("Audio buffer overflow!")
            pcm_bytes = bytes(indata)
            
            def safe_put(item):
                if not queue.full():
                    queue.put_nowait(item)
            
            loop.call_soon_threadsafe(safe_put, pcm_bytes)

        with sd.InputStream(samplerate=16000, channels=1, dtype='int16', callback=mic_callback), \
             sd.OutputStream(samplerate=16000, channels=1, dtype='int16') as speaker:
            
            print("Waiting for session to be ready...")
            
            try:
                while True:
                    try:
                        response_data = await websocket.recv()
                        
                        if isinstance(response_data, (bytes, bytearray)) and len(response_data):
                            speaker.write(np.frombuffer(response_data, dtype=np.int16))
                            
                        elif isinstance(response_data, str):
                            try:
                                message = json.loads(response_data)
                                
                                if message.get("type") == "session.created":
                                    print("Session created, voice chat is now active. Press Ctrl+C to quit.")
                                    session_ready = True
                                elif message.get("type") == "conversation.item.done":
                                    item = message.get("item", {})
                                    role = item.get("role", "unknown")
                                    content = item.get("content", [])
                                    if content and len(content) > 0:
                                        text = content[0].get("text", "")
                                        if interim_active:
                                            print("\r" + " " * 100 + "\r", end='')
                                            interim_active = False
                                        print(f"[{role}]: {text}")
                                        
                                elif message.get("type") == "conversation.item.interim":
                                    item = message.get("item", {})
                                    role = item.get("role", "unknown")
                                    content = item.get("content", [])
                                    if content and len(content) > 0:
                                        text = content[0].get("text", "")
                                        if role == "user":
                                            print(f"\rðŸŽ¤ {text}...", end='', flush=True)
                                            interim_active = True
                                        
                            except json.JSONDecodeError:
                                print(f"Received non-JSON text message: {response_data}")
                                
                    except websockets.exceptions.ConnectionClosedOK:
                        print("Server closed connection cleanly.")
                        break
                        
            except asyncio.CancelledError:
                pass
            except KeyboardInterrupt:
                print("\nDisconnecting...")

        sender_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await sender_task

if __name__ == "__main__":
    try:
        asyncio.run(voice_chat())
    except KeyboardInterrupt:
        print("\nExiting...")
```
