---
title: "Code Switching"
---

Transcribe audio containing multiple languages with code switching detection. This feature enables accurate transcription of conversations where speakers naturally switch between languages during conversations.

## What is code switching?

Code switching occurs when speakers alternate between languages in dialogue.

Our code switching feature detects and transcribes these language transitions, maintaining accuracy across languages.

## How it works

When you submit a file with code-switching dialogue, our model can transcribe both languages, with optimal performance for English paired with another language. The key to effective code switching transcription is selecting the appropriate primary language parameter. For Spanish and German, paired with English, the model performs equally well regardless of which language dominates the conversation.

## Best practices

1. **Language Selection**: For English paired with Spanish or German, specify the non-English language as the primary language. This approach works equally well whether English or the other language dominates the conversation. For other language pairs, this strategy works best when the non-English language is dominant in the audio.

2. **Avoid Automatic Detection**: Do not use automatic language detection (`language_detection=True`) for code-switched content, as it may default to English and produce poor results for non-English segments.

3. **Testing**: Test with sample audio to determine the best language parameter for your specific use case.

<Note title="Language Selection Strategy">
  For best results with code-switched content please do the following based on
  the language combination: - **Spanish/German + English**: Specify the
  non-English language as primary (e.g., `es` for Spanish). This works equally
  well regardless of language dominance. - **Other languages + English**:
  Specify the non-English language as primary only when that language is
  dominant in the audio. For English-dominant content with other languages,
  standard English transcription may be more appropriate. - This approach
  prevents the model from overfitting to English and producing poor results for
  non-English segments.
</Note>

## Supported language pairs

Code switching performance varies by language pair.

**Optimal performance (works equally well regardless of language dominance):**

- English + Spanish
- English + German

**Other supported languages:**

While additional languages are supported for code switching, optimal results typically require the non-English language to be dominant in the audio. For English-dominant content with other languages, standard single-language transcription may be more appropriate.

We highly recommend testing sample code switching files with your specific audio to assess performance and evaluate outputs. We also recommend using an LLM to correct and fine-tune our model's outputs.

## Code switching implementation

<CodeBlocks>

```python title="Python SDK" highlight={8} maxLines=15
import assemblyai as aai

aai.settings.api_key = "<YOUR_API_KEY>"

audio_file = "https://assembly.ai/spanglish.mp3"

# Set Spanish as primary language for English-Spanish mixing
config = aai.TranscriptionConfig(language_code="es")

transcript = aai.Transcriber(config=config).transcribe(audio_file)

print(transcript.text)
```

```python title="Python" highlight={19} maxLines=15
import requests
import time

base_url = "https://api.assemblyai.com"

headers = {
    "authorization": "<YOUR_API_KEY>"
}

with open("./bilingual-audio.mp3", "rb") as f:
  response = requests.post(base_url + "/v2/upload",
                          headers=headers,
                          data=f)

upload_url = response.json()["upload_url"]

data = {
    "audio_url": upload_url,
    "language_code": "es"  # Spanish for English-Spanish code switching
}

url = base_url + "/v2/transcript"
response = requests.post(url, json=data, headers=headers)

transcript_id = response.json()['id']
polling_endpoint = base_url + "/v2/transcript/" + transcript_id

while True:
  transcription_result = requests.get(polling_endpoint, headers=headers).json()

  if transcription_result['status'] == 'completed':
    print(f"Transcript:", transcription_result['text'])
    break

  elif transcription_result['status'] == 'error':
    raise RuntimeError(f"Transcription failed: {transcription_result['error']}")

  else:
    time.sleep(3)
```

```javascript title="JavaScript SDK" highlight={12} maxLines=15
import { AssemblyAI } from "assemblyai";

const client = new AssemblyAI({
  apiKey: "<YOUR_API_KEY>",
});

const audioFile = "https://assembly.ai/spanglish.mp3";

const params = {
  audio: audioFile,
  // Spanish for English-Spanish code switching
  language_code: "es",
};

const run = async () => {
  const transcript = await client.transcripts.transcribe(params);

  console.log(transcript.text);
};

run();
```

```javascript title="JavaScript" highlight={19} maxLines=15
import axios from "axios";
import fs from "fs-extra";

const baseUrl = "https://api.assemblyai.com";

const headers = {
  authorization: "<YOUR_API_KEY>",
};

const path = "./bilingual-audio.mp3";
const audioData = await fs.readFile(path);
const uploadResponse = await axios.post(`${baseUrl}/v2/upload`, audioData, {
  headers,
});
const uploadUrl = uploadResponse.data.upload_url;

const data = {
  audio_url: uploadUrl,
  language_code: "es", // Spanish for English-Spanish code switching
};

const url = `${baseUrl}/v2/transcript`;
const response = await axios.post(url, data, { headers: headers });

const transcriptId = response.data.id;
const pollingEndpoint = `${baseUrl}/v2/transcript/${transcriptId}`;

while (true) {
  const pollingResponse = await axios.get(pollingEndpoint, {
    headers: headers,
  });
  const transcriptionResult = pollingResponse.data;

  if (transcriptionResult.status === "completed") {
    console.log(transcriptionResult.text);
    break;
  } else if (transcriptionResult.status === "error") {
    throw new Error(`Transcription failed: ${transcriptionResult.error}`);
  } else {
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}
```

```csharp title="C#" highlight={68} maxLines=15
using System;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

public class Transcript
{
    public string Id { get; set; }
    public string Status { get; set; }
    public string Text { get; set; }
    public string Error { get; set; }
}

class Program
{
    static void Main(string[] args)
    {
        MainAsync(args).GetAwaiter().GetResult();
    }

    static async Task MainAsync(string[] args)
    {
        using (var httpClient = new HttpClient())
        {
            httpClient.DefaultRequestHeaders.Add("authorization", "<YOUR-API-KEY>");

            var localFilePath = "bilingual-audio.mp3";

            Console.WriteLine("Uploading file...");
            var uploadUrl = await UploadFileAsync(localFilePath, httpClient);

            Console.WriteLine("Creating transcript with code switching...");
            var transcript = await CreateTranscriptAsync(uploadUrl, httpClient);

            Console.WriteLine("Waiting for transcript...");
            transcript = await WaitForTranscriptToProcess(transcript, httpClient);

            Console.WriteLine("Transcription completed!");
            Console.WriteLine("----------------------------------");
            Console.WriteLine(transcript.Text);
        }
    }

    static async Task<string> UploadFileAsync(string filePath, HttpClient httpClient)
    {
        using (var fileStream = File.OpenRead(filePath))
        using (var content = new StreamContent(fileStream))
        {
            content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");

            var response = await httpClient.PostAsync("https://api.assemblyai.com/v2/upload", content);
            response.EnsureSuccessStatusCode();

            var jsonDoc = await response.Content.ReadFromJsonAsync<JsonDocument>();
            return jsonDoc.RootElement.GetProperty("upload_url").GetString();
        }
    }

    static async Task<Transcript> CreateTranscriptAsync(string audioUrl, HttpClient httpClient)
    {
        var data = new
        {
            audio_url = audioUrl,
            language_code = "es" // Spanish for English-Spanish code switching
        };

        var content = new StringContent(JsonSerializer.Serialize(data), Encoding.UTF8, "application/json");

        using (var response = await httpClient.PostAsync("https://api.assemblyai.com/v2/transcript", content))
        {
            response.EnsureSuccessStatusCode();
            return await response.Content.ReadFromJsonAsync<Transcript>();
        }
    }

    static async Task<Transcript> WaitForTranscriptToProcess(Transcript transcript, HttpClient httpClient)
    {
        var pollingEndpoint = $"https://api.assemblyai.com/v2/transcript/{transcript.Id}";

        while (true)
        {
            var pollingResponse = await httpClient.GetAsync(pollingEndpoint);
            transcript = await pollingResponse.Content.ReadFromJsonAsync<Transcript>();

            switch (transcript.Status)
            {
                case "processing":
                case "queued":
                    Console.WriteLine($"Status: {transcript.Status}... waiting...");
                    await Task.Delay(TimeSpan.FromSeconds(3));
                    break;
                case "completed":
                    return transcript;
                case "error":
                    throw new Exception($"Transcription failed: {transcript.Error}");
                default:
                    throw new Exception("Unexpected transcript status.");
            }
        }
    }
}
```

```ruby title="Ruby" highlight={23} maxLines=15
require 'net/http'
require 'json'

base_url = 'https://api.assemblyai.com'

headers = {
  'authorization' => '<YOUR_API_KEY>',
  'content-type' => 'application/json'
}

path = "./bilingual-audio.mp3"
uri = URI("#{base_url}/v2/upload")
request = Net::HTTP::Post.new(uri, headers)
request.body = File.read(path)

http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = true
upload_response = http.request(request)
upload_url = JSON.parse(upload_response.body)["upload_url"]

data = {
    "audio_url" => upload_url,
    "language_code" => "es" # Spanish for English-Spanish code switching
}

uri = URI.parse("#{base_url}/v2/transcript")
http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = true

request = Net::HTTP::Post.new(uri.request_uri, headers)
request.body = data.to_json

response = http.request(request)
response_body = JSON.parse(response.body)

unless response.is_a?(Net::HTTPSuccess)
  raise "API request failed with status #{response.code}: #{response.body}"
end

transcript_id = response_body['id']
puts "Transcript ID: #{transcript_id}"

polling_endpoint = URI.parse("#{base_url}/v2/transcript/#{transcript_id}")

while true
  polling_http = Net::HTTP.new(polling_endpoint.host, polling_endpoint.port)
  polling_http.use_ssl = true
  polling_request = Net::HTTP::Get.new(polling_endpoint.request_uri, headers)
  polling_response = polling_http.request(polling_request)

  transcription_result = JSON.parse(polling_response.body)

  if transcription_result['status'] == 'completed'
    puts "Transcription text: #{transcription_result['text']}"
    break
  elsif transcription_result['status'] == 'error'
    raise "Transcription failed: #{transcription_result['error']}"
  else
    puts 'Waiting for transcription to complete...'
    sleep(3)
  end
end
```

```php title="PHP" highlight={30} maxLines=15
<?php
$ch = curl_init();
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

$base_url = "https://api.assemblyai.com";

$headers = array(
    "authorization: <YOUR_API_KEY>",
    "content-type: application/json"
);

$path = "./bilingual-audio.mp3";

$ch = curl_init();

curl_setopt($ch, CURLOPT_URL, $base_url . "/v2/upload");
curl_setopt($ch, CURLOPT_POST, 1);
curl_setopt($ch, CURLOPT_POSTFIELDS, file_get_contents($path));
curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

$response = curl_exec($ch);
$response_data = json_decode($response, true);
$upload_url = $response_data["upload_url"];

curl_close($ch);

$data = array(
    "audio_url" => $upload_url,
    "language_code" => "es" // Spanish for English-Spanish code switching
);

$url = $base_url . "/v2/transcript";
$curl = curl_init($url);

curl_setopt($curl, CURLOPT_POST, true);
curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode($data));
curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);

$response = curl_exec($curl);

$response = json_decode($response, true);

curl_close($curl);

$transcript_id = $response['id'];
echo "Transcript ID: $transcript_id\n";

$polling_endpoint = $base_url . "/v2/transcript/" . $transcript_id;

while (true) {
    $polling_response = curl_init($polling_endpoint);

    curl_setopt($polling_response, CURLOPT_HTTPHEADER, $headers);
    curl_setopt($polling_response, CURLOPT_RETURNTRANSFER, true);

    $transcription_result = json_decode(curl_exec($polling_response), true);

    if ($transcription_result['status'] === "completed") {
        echo $transcription_result['text'];
        break;
    } else if ($transcription_result['status'] === "error") {
        throw new Exception("Transcription failed: " . $transcription_result['error']);
    } else {
        sleep(3);
    }
}
```

</CodeBlocks>

## Example output

Here's what you can expect from a properly configured code-switching transcription:

**Input**: Audio containing English and Spanish conversation

**Configuration**: `language_code="es"`

```
Original: "Hola, how are you today? Estoy muy bien, gracias. I wanted to discuss el proyecto that we talked about yesterday."

Transcribed: "Hola, how are you today? Estoy muy bien, gracias. I wanted to discuss el proyecto that we talked about yesterday."
```

The transcription maintains accuracy across both languages without attempting to force everything into a single language.

## Troubleshooting

<Tip title="Poor transcription quality?">
  If you're getting gibberish or incorrect transcriptions: 1. Ensure you're NOT
  using `language_code="en"` for English-mixed content 2. Try setting the
  non-English language as the primary language 3. Avoid using automatic language
  detection for code-switched audio
</Tip>

<Warning>
  If your audio contains primarily one language with only occasional words from
  another language, standard single-language transcription may be more
  appropriate than code-switching mode.
</Warning>

## Related features

- [Supported Languages](/docs/speech-to-text/pre-recorded-audio/supported-languages) - View all available language options
- [Speaker Diarization](/docs/speech-to-text/speaker-diarization) - Identify different speakers in multi-speaker conversations
- [Custom Vocabulary](/docs/speech-to-text/custom-vocabulary) - Add specialized terms in multiple languages
