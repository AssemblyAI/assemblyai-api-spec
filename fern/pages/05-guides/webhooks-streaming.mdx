---
title: "Webhooks for streaming speech-to-text"
hide-nav-links: true
description: "Get notified when a streaming transcription session ends."
---

Webhooks allow you to receive the complete transcript via HTTP callback when a streaming session ends. This is in addition to the normal WebSocket responses you receive during the session.

<Note>
  This guide covers webhooks for [streaming audio
  transcription](/docs/speech-to-text/universal-streaming). For webhooks with
  pre-recorded audio, see [Webhooks for pre-recorded
  audio](/docs/deployment/webhooks).
</Note>

## Configure webhooks for a streaming session

To use webhooks with streaming speech-to-text, add the following parameters to your WebSocket connection URL:

| Parameter                   | Required | Description                                                               |
| --------------------------- | -------- | ------------------------------------------------------------------------- |
| `webhook_url`               | Yes      | The URL to send the transcript to when the session ends.                  |
| `webhook_auth_header_name`  | No       | The name of the authentication header to include in the webhook request.  |
| `webhook_auth_header_value` | No       | The value of the authentication header to include in the webhook request. |

<Tip title="Don't have a webhook endpoint yet?">
  Create a test webhook endpoint with [webhook.site](https://webhook.site) to
  test your webhook integration.
</Tip>

### Example WebSocket URL with webhook parameters

Add the webhook parameters as query parameters to the WebSocket URL:

```
wss://streaming.assemblyai.com/v3/ws?sample_rate=16000&webhook_url=https://example.com/webhook
```

To include authentication:

```
wss://streaming.assemblyai.com/v3/ws?sample_rate=16000&webhook_url=https://example.com/webhook&webhook_auth_header_name=X-Webhook-Secret&webhook_auth_header_value=secret-value
```

<Tabs>
<Tab language="python" title="Python">

```python
import pyaudio
import websocket
import json
import threading
import time
from urllib.parse import urlencode
from datetime import datetime

# --- Configuration ---
YOUR_API_KEY = "<YOUR_API_KEY>"

CONNECTION_PARAMS = {
    "sample_rate": 16000,
    "format_turns": True,
    # Webhook parameters
    "webhook_url": "https://example.com/webhook",
    "webhook_auth_header_name": "X-Webhook-Secret",  # Optional
    "webhook_auth_header_value": "secret-value",  # Optional
}
API_ENDPOINT_BASE_URL = "wss://streaming.assemblyai.com/v3/ws"
API_ENDPOINT = f"{API_ENDPOINT_BASE_URL}?{urlencode(CONNECTION_PARAMS)}"

# Audio Configuration
FRAMES_PER_BUFFER = 800  # 50ms of audio (0.05s * 16000Hz)
SAMPLE_RATE = CONNECTION_PARAMS["sample_rate"]
CHANNELS = 1
FORMAT = pyaudio.paInt16

# Global variables
audio = None
stream = None
ws_app = None
audio_thread = None
stop_event = threading.Event()


def on_open(ws):
    """Called when the WebSocket connection is established."""
    print("WebSocket connection opened.")
    print(f"Connected to: {API_ENDPOINT}")

    def stream_audio():
        global stream
        print("Starting audio streaming...")
        while not stop_event.is_set():
            try:
                audio_data = stream.read(FRAMES_PER_BUFFER, exception_on_overflow=False)
                ws.send(audio_data, websocket.ABNF.OPCODE_BINARY)
            except Exception as e:
                print(f"Error streaming audio: {e}")
                break
        print("Audio streaming stopped.")

    global audio_thread
    audio_thread = threading.Thread(target=stream_audio)
    audio_thread.daemon = True
    audio_thread.start()


def on_message(ws, message):
    """Called when a message is received from the WebSocket."""
    try:
        data = json.loads(message)
        msg_type = data.get("type")

        if msg_type == "Begin":
            session_id = data.get("id")
            expires_at = data.get("expires_at")
            print(f"\nSession began: ID={session_id}, ExpiresAt={datetime.fromtimestamp(expires_at)}")
        elif msg_type == "Turn":
            transcript = data.get("transcript", "")
            formatted = data.get("turn_is_formatted", False)
            if formatted:
                print("\r" + " " * 80 + "\r", end="")
                print(transcript)
            else:
                print(f"\r{transcript}", end="")
        elif msg_type == "Termination":
            audio_duration = data.get("audio_duration_seconds", 0)
            session_duration = data.get("session_duration_seconds", 0)
            print(f"\nSession Terminated: Audio Duration={audio_duration}s, Session Duration={session_duration}s")
    except json.JSONDecodeError as e:
        print(f"Error decoding message: {e}")
    except Exception as e:
        print(f"Error handling message: {e}")


def on_error(ws, error):
    """Called when a WebSocket error occurs."""
    print(f"\nWebSocket Error: {error}")
    stop_event.set()


def on_close(ws, close_status_code, close_msg):
    """Called when the WebSocket connection is closed."""
    print(f"\nWebSocket Disconnected: Status={close_status_code}, Msg={close_msg}")
    global stream, audio
    stop_event.set()

    if stream:
        if stream.is_active():
            stream.stop_stream()
        stream.close()
        stream = None
    if audio:
        audio.terminate()
        audio = None
    if audio_thread and audio_thread.is_alive():
        audio_thread.join(timeout=1.0)


def run():
    global audio, stream, ws_app

    audio = pyaudio.PyAudio()

    try:
        stream = audio.open(
            input=True,
            frames_per_buffer=FRAMES_PER_BUFFER,
            channels=CHANNELS,
            format=FORMAT,
            rate=SAMPLE_RATE,
        )
        print("Microphone stream opened successfully.")
        print("Speak into your microphone. Press Ctrl+C to stop.")
    except Exception as e:
        print(f"Error opening microphone stream: {e}")
        if audio:
            audio.terminate()
        return

    ws_app = websocket.WebSocketApp(
        API_ENDPOINT,
        header={"Authorization": YOUR_API_KEY},
        on_open=on_open,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close,
    )

    ws_thread = threading.Thread(target=ws_app.run_forever)
    ws_thread.daemon = True
    ws_thread.start()

    try:
        while ws_thread.is_alive():
            time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nCtrl+C received. Stopping...")
        stop_event.set()

        if ws_app and ws_app.sock and ws_app.sock.connected:
            try:
                terminate_message = {"type": "Terminate"}
                ws_app.send(json.dumps(terminate_message))
                time.sleep(2)
            except Exception as e:
                print(f"Error sending termination message: {e}")

        if ws_app:
            ws_app.close()
        ws_thread.join(timeout=2.0)

    finally:
        if stream and stream.is_active():
            stream.stop_stream()
        if stream:
            stream.close()
        if audio:
            audio.terminate()
        print("Cleanup complete.")


if __name__ == "__main__":
    run()
```

</Tab>
<Tab language="javascript" title="JavaScript">

```javascript
const WebSocket = require("ws");

const API_KEY = "<YOUR_API_KEY>";

const connectionParams = new URLSearchParams({
  sample_rate: 16000,
  format_turns: true,
  // Webhook parameters
  webhook_url: "https://example.com/webhook",
  webhook_auth_header_name: "X-Webhook-Secret", // Optional
  webhook_auth_header_value: "secret-value", // Optional
});

const API_ENDPOINT = `wss://streaming.assemblyai.com/v3/ws?${connectionParams.toString()}`;

const ws = new WebSocket(API_ENDPOINT, {
  headers: {
    Authorization: API_KEY,
  },
});

ws.on("open", () => {
  console.log("WebSocket connection opened.");
  console.log(`Connected to: ${API_ENDPOINT}`);

  // Start streaming audio data here
  // For example, using a microphone input library
});

ws.on("message", (data) => {
  try {
    const message = JSON.parse(data);
    const msgType = message.type;

    if (msgType === "Begin") {
      const sessionId = message.id;
      const expiresAt = new Date(message.expires_at * 1000);
      console.log(`\nSession began: ID=${sessionId}, ExpiresAt=${expiresAt}`);
    } else if (msgType === "Turn") {
      const transcript = message.transcript || "";
      const formatted = message.turn_is_formatted || false;
      if (formatted) {
        process.stdout.write("\r" + " ".repeat(80) + "\r");
        console.log(transcript);
      } else {
        process.stdout.write(`\r${transcript}`);
      }
    } else if (msgType === "Termination") {
      const audioDuration = message.audio_duration_seconds || 0;
      const sessionDuration = message.session_duration_seconds || 0;
      console.log(
        `\nSession Terminated: Audio Duration=${audioDuration}s, Session Duration=${sessionDuration}s`
      );
    }
  } catch (e) {
    console.error("Error handling message:", e);
  }
});

ws.on("error", (error) => {
  console.error("WebSocket Error:", error);
});

ws.on("close", (code, reason) => {
  console.log(`WebSocket Disconnected: Status=${code}, Msg=${reason}`);
});

// To gracefully close the session, send a Terminate message
function terminateSession() {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "Terminate" }));
  }
}
```

</Tab>
</Tabs>

## Handle webhook deliveries

When the streaming session ends, AssemblyAI sends a `POST` HTTP request to the URL you specified. The webhook contains the complete transcript from the session.

<Note title="Static Webhook IP addresses">

AssemblyAI sends all webhook deliveries from fixed IP addresses:

| Region | IP Address     |
| ------ | -------------- |
| US     | `44.238.19.20` |
| EU     | `54.220.25.36` |

</Note>

### Delivery payload

The webhook delivery payload contains the complete transcript from the streaming session as a JSON object. The payload includes all the final transcript segments combined.

### Example webhook receiver

<Tabs>
<Tab language="python" title="Python (Flask)">

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route("/webhook", methods=["POST"])
def webhook():
    # Verify the authentication header if you configured one
    auth_header = request.headers.get("X-Webhook-Secret")
    if auth_header != "secret-value":
        return jsonify({"error": "Unauthorized"}), 401

    # Process the transcript data
    data = request.json
    print("Received transcript:", data)

    # Return a success response
    return jsonify({"status": "received"}), 200

if __name__ == "__main__":
    app.run(port=5000)
```

</Tab>
<Tab language="javascript" title="JavaScript (Express)">

```javascript
const express = require("express");
const app = express();

app.use(express.json());

app.post("/webhook", (req, res) => {
  // Verify the authentication header if you configured one
  const authHeader = req.headers["x-webhook-secret"];
  if (authHeader !== "secret-value") {
    return res.status(401).json({ error: "Unauthorized" });
  }

  // Process the transcript data
  const data = req.body;
  console.log("Received transcript:", data);

  // Return a success response
  res.status(200).json({ status: "received" });
});

app.listen(5000, () => {
  console.log("Webhook server listening on port 5000");
});
```

</Tab>
</Tabs>

## Authenticate webhook deliveries

To secure your webhook endpoint, you can include custom authentication headers in the webhook request. When configuring your streaming session, provide the `webhook_auth_header_name` and `webhook_auth_header_value` parameters.

AssemblyAI will include this header in the webhook request, allowing you to verify that the request came from AssemblyAI.

```
webhook_auth_header_name=X-Webhook-Secret&webhook_auth_header_value=secret-value
```

In your webhook receiver, verify the header value matches what you configured:

```python
auth_header = request.headers.get("X-Webhook-Secret")
if auth_header != "secret-value":
    return "Unauthorized", 401
```

## Best practices

When implementing webhooks for streaming speech-to-text, consider the following best practices:

1. **Always verify authentication**: If you configure an authentication header, always verify it in your webhook receiver to ensure requests are from AssemblyAI.

2. **Respond quickly**: Return a response from your webhook endpoint as quickly as possible. If you need to perform time-consuming processing, do it asynchronously after returning the response.

3. **Handle failures gracefully**: Your webhook endpoint should handle errors gracefully and return appropriate HTTP status codes.

4. **Use HTTPS**: Always use HTTPS for your webhook URL to ensure the transcript data is encrypted in transit.

5. **Log webhook deliveries**: Keep logs of webhook deliveries for debugging and auditing purposes.
